/*
 *  Generated by json_rpc_api_plugin on protobuf 3.11.2
 */
#include "rpc_api.proto.h"
#include <grpcbackend/util/json_rpc.h>
#include <openssl/evp.h>

static std::string base64_encode(const std::string& in) {
	const int pl = 3*in.size()/4;
	std::string output(pl + 1, '\0'); //+1 for the terminating null that EVP_EncodeBlock adds on
	const auto ol = EVP_EncodeBlock(reinterpret_cast<unsigned char *>(const_cast<char*>(output.data())), reinterpret_cast<const unsigned char *>(in.data()), in.size());
	if (pl != ol) throw std::runtime_error("base64_encode predicted " + std::to_string(pl) + " but we got " + std::to_string(ol));
	return output;
}

static std::string base64_decode(const std::string& in) {
	const int pl = 4*((in.size()+2)/3);
	std::string output(pl + 1, '\0'); //+1 for the terminating null that EVP_EncodeBlock adds on
	const auto ol = EVP_DecodeBlock(reinterpret_cast<unsigned char *>(const_cast<char*>(output.data())), reinterpret_cast<const unsigned char *>(in.data()), in.size());
	if (pl != ol) throw std::runtime_error("base64_decode predicted " + std::to_string(pl) + " but we got " + std::to_string(ol));
	return output;
}
namespace test {

static TestRequest_SubMessage_TestEnum string_to_enum_TestRequest_SubMessage_TestEnum(const std::string& str) {
	if(str == "TEST") return TestRequest_SubMessage_TestEnum::TEST;
	if(str == "TEST2") return TestRequest_SubMessage_TestEnum::TEST2;
	throw std::runtime_error("invalid value for enum");
}

picojson::value TestRequest_SubMessage::to_json() const {
	picojson::object obj;
	obj.emplace("test", picojson::value(static_cast<int64_t>(test)));
	obj.emplace("_enum", picojson::value(static_cast<int64_t>(_enum)));
	obj.emplace("bfield", picojson::value(base64_encode(bfield)));
	return picojson::value(obj);
}

void TestRequest_SubMessage::from_json(const picojson::value& val) {
	if(!val.is<picojson::object>()) throw std::runtime_error("invalid json supplied");
	auto& obj = val.get<picojson::object>();

	if(obj.count("test") == 0)
		throw std::runtime_error("json missing required member test");
	{
		if(!obj.at("test").is<int64_t>()) throw std::runtime_error("test must be a number");
		this->test = obj.at("test").get<int64_t>();
	}
	if(obj.count("_enum") == 0)
		throw std::runtime_error("json missing required member _enum");
	{
		if(obj.at("_enum").is<int64_t>())
			this->_enum = static_cast<TestRequest_SubMessage_TestEnum>(obj.at("_enum").get<int64_t>());
		else if(obj.at("_enum").is<std::string>())
			this->_enum = string_to_enum_TestRequest_SubMessage_TestEnum(obj.at("_enum").get<std::string>());
		else throw std::runtime_error("_enum must be a number or string");
	}
	if(obj.count("bfield") == 0)
		throw std::runtime_error("json missing required member bfield");
	{
		if(!obj.at("bfield").is<std::string>()) throw std::runtime_error("bfield must be a string");
		this->bfield = base64_decode(obj.at("bfield").get<std::string>());
	}
}

picojson::value TestRequest::to_json() const {
	picojson::object obj;
	obj.emplace("request", picojson::value(request));
	obj.emplace("msg", msg.to_json());
	return picojson::value(obj);
}

void TestRequest::from_json(const picojson::value& val) {
	if(!val.is<picojson::object>()) throw std::runtime_error("invalid json supplied");
	auto& obj = val.get<picojson::object>();

	if(obj.count("request") == 0)
		throw std::runtime_error("json missing required member request");
	{
		if(!obj.at("request").is<std::string>()) throw std::runtime_error("request must be a string");
		this->request = obj.at("request").get<std::string>();
	}
	if(obj.count("msg") == 0)
		throw std::runtime_error("json missing required member msg");
	{
		if(!obj.at("msg").is<picojson::object>()) throw std::runtime_error("msg must be an object");
		msg.from_json(obj.at("msg"));
	}
}

picojson::value TestResponse::to_json() const {
	picojson::object obj;
	obj.emplace("response", picojson::value(response));
	return picojson::value(obj);
}

void TestResponse::from_json(const picojson::value& val) {
	if(!val.is<picojson::object>()) throw std::runtime_error("invalid json supplied");
	auto& obj = val.get<picojson::object>();

	if(obj.count("response") == 0)
		throw std::runtime_error("json missing required member response");
	{
		if(!obj.at("response").is<std::string>()) throw std::runtime_error("response must be a string");
		this->response = obj.at("response").get<std::string>();
	}
}

void TestService::register_service(thalhammer::grpcbackend::util::json_rpc& rpc) {
	rpc.register_method("test.TestService.Test", [this](std::shared_ptr<thalhammer::grpcbackend::util::json_rpc::call_context> ctx) {
		std::shared_ptr<thalhammer::grpcbackend::util::json_rpc_query<TestRequest, TestResponse>> mctx;
		try {
			mctx = std::make_shared<thalhammer::grpcbackend::util::json_rpc_query<TestRequest, TestResponse>>(ctx);
		} catch(const std::exception& e) {
			return ctx->error(thalhammer::grpcbackend::util::json_rpc::ERROR_INVALID_PARAMS, e.what());
		}
		try {
			this->Test(mctx);
		} catch(const std::exception& e) {
			return ctx->error(thalhammer::grpcbackend::util::json_rpc::ERROR_INTERNAL, e.what());
		}
	});
}

} /* test */

